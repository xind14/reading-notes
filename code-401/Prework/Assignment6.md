# Engineering Readings

## 1. **Act Like You Make $1000/hr**

- Didn't read it. Had to sign up to read.

## 2. **How to Think Like a Programmer**

The best way involves having a framework and practicing it.

### So, what should you do when you encounter a new problem?

1. **Understand**

   - Know exactly what is being asked. Most hard problems are hard because you don’t understand them.
   - How to know when you understand a problem? When you can explain it in plain English.

2. **Plan**

   - Don’t dive right into solving without a plan (and somehow hope you can muddle your way through). Plan your solution!

3. **Divide**

   - Break it into sub-problems. These sub-problems are much easier to solve.

   - Then, solve each sub-problem one by one. Begin with the simplest. Simplest means you know the answer (or are closer to that answer).

   - After that, simplest means this sub-problem being solved doesn’t depend on others being solved.

   - Once you solved every sub-problem, connect the dots.

4. **Stuck?**

   - **Debug:** Go step by step through your solution trying to find where you went wrong. Programmers call this debugging (in fact, this is all a debugger does).

   > “The art of debugging is figuring out what you really told your program to do rather than what you thought you told it to do.”” — Andrew Singer

   - **Reassess:** Take a step back. Look at the problem from another perspective. Is there anything that can be abstracted to a more general approach?

   Sidenote: Another way of reassessing is starting anew. Delete everything and begin again with fresh eyes. I’m serious. You’ll be dumbfounded at how effective this is.

   - **Research:** Ahh, good ol’ Google. You read that right. No matter what problem you have, someone has probably solved it. Find that person/ solution. In fact, do this even if you solved the problem! (You can learn a lot from other people’s solutions).

   Caveat: Don’t look for a solution to the big problem. Only look for solutions to sub-problems. Why? Because unless you struggle (even a little bit), you won’t learn anything. If you don’t learn anything, you wasted your time.

## 3. **Solving Problems**

1. **Read the problem completely twice.**

   - This is the single most important step.
   - If you don’t understand the problem, you cannot solve it. Do not worry about wasting time here, because the better you understand the problem, the easier it will be to solve it. If you are given any examples along with the problem, make sure you have worked through the examples and understand why the answers are correct for each one.

2. **Solve the problem manually with 3 sets of sample data.**

3. **Optimize the manual steps.**

   - What you want to do here is figure out if there is another way you can solve the problem easier, or if there are some steps you can cut out or simplify.

4. **Write the manual steps as comments or pseudo-code.**

   - What we want to do here is capture all the steps we created and now either put them into our editor as comments or write them as pseudo-code that we can translate to real code.

5. **Replace the comments or pseudo-code with real code.**

   - If you struggle here, there are usually two possible reasons:
     1. You didn’t break down the problem into small enough steps.
     2. You don’t know your programming language well enough to do the conversion.
   - If you didn’t break the problem down enough, try going back to the second step and being as meticulous as possible. Write out each and every single step.

6. **Optimize the real code.**

## 4. **The 5 Whys**

The 5 Whys can be employed for troubleshooting, quality improvement, and problem-solving, especially for simple or moderately difficult problems.

1. **Assemble a Team**: Gather individuals familiar with the problem and the relevant process. Include a facilitator to keep the team focused on effective counter-measures.

2. **Define the Problem**: Observe the problem and discuss it with the team. Formulate a clear problem statement everyone agrees on. Write it on a whiteboard or sticky note.

3. **Ask the First "Why?"**: Question why the problem is occurring. Seek factual answers grounded in actual events, not speculative guesses. Record the answers succinctly below the problem statement.

4. **Ask "Why?" Four More Times**: For each answer from Step 3, ask "why" successively. Frame each question in response to the previous answer. Follow multiple lanes of inquiry if necessary.

5. **Know When to Stop**: Stop when further "why" questions produce no more useful responses. At this point, an appropriate counter-measure or process change should become evident.

6. **Address the Root Cause(s)**: Discuss and agree on counter-measures to prevent the problem's recurrence.

7. **Monitor Your Measures**: Keep a close watch on the effectiveness of counter-measures. Adjust or replace them as needed, and consider repeating the 5 Whys process to validate the root cause.

## 5. **The Super Mario Effect**

- Emphasizes focusing on the end goal rather than fearing failure.
- "Life gamification" involves approaching challenges with a positive attitude and embracing failures as opportunities to learn.

- Encourages reframing the learning process to make it enjoyable and natural.

- Emphasizes the value of embracing challenges, failures, and setbacks for meaningful success and learning.

## Discussion Questions

After engaging with these materials, reflect on the following questions to enhance your understanding and application:

1. **What’s the one thing I bring to this career (and a potential employer) that nobody else can?**
   - My advantage lies in my extensive experience in client-facing roles, and understanding the importance of seamless user interactions.
2. **What are 3 things I’ll start doing to “un-stick” myself whenever I get stuck on a tough piece of code, logic, or feature?**
   - I will proactively seek collaboration with team members, explore documentation, online forums, and relevant resources, step away from the problem when feeling stuck. Returning with a fresh perspective
